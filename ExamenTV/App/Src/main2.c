/*
 * main2.c
 *
 *  Created on: 28/05/2023
 *      Author: marianela
 */


/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

// se incluyen archivos de cabecera que necesitamos en el proyecto
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "stm32f4xx.h"
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "PllDriver.h"

// Definicion de los handlers necesarios
GPIO_Handler_t handlerStateLed = {0};
GPIO_Handler_t handlerPinTx		= {0};
GPIO_Handler_t handlerPinRx		= {0};

// Timer encargado del Blinky
BasicTimer_Handler_t handlerStateTimer = {0};

// Utiliza la conexion USB
USART_Handler_t handlerUsart2 = {0};

uint8_t rxData = 0;
char bufferData[64];
char cmd[64];
#define BUFFER_SIZE 150
char bufferReception[BUFFER_SIZE];
uint8_t counterReception;
bool stringComplete = false;
char userMsg[64] = "\0";

unsigned int firstParameter;
unsigned int secondParameter;
unsigned int secondParameter;

//Pll

CLOCK_Handler_t handlerFrequency = {0};
CLOCK_Handler_t handlerPllMCO = {0};
GPIO_Handler_t handlerMCO1Pin = {0};




/* Definición de prototipos de funciones */
void InitSystem(void);
void parseCommands(char *prtBufferReception);
/**
 * Funcion principal del programa.
 * Esta funcion es el corazón del programa!!
 *
 * */
int main(void) {

	// Inicializamos todos los elementos del sistema
	InitSystem();

	/* Loop forever */
	while (1) {



		// Creamos una cadena de caracteres con los datos que llegan por el
		// El caracter '@' nos indica que es el finall de la cadena
		if (rxData !=0){
			bufferReception[counterReception] = rxData;
			counterReception++;
			// si el carácter entrante es una nueva línea, establece una bandera
			// para que el ciclo principal pueda hacer algo al respecto:
			if ( rxData == '@'){
				stringComplete = true;
				// Agrego esta linea para crear el string con el null al fin
				bufferReception[counterReception] = '\0';
				counterReception = 0;
			}
			//Para ue no vuelva a entrar. Solo cambia debido a la interrupción
			rxData = '\0';
		}
		//Hacemos un analisis de la cadena de datos obtenida
		if(stringComplete){
			parseCommands(bufferReception);
			stringComplete = false;
		}


	}

	return 0;
}




void parseCommands(char *prtBufferReception){

	// Esta función de C lee la cadena de caracteres a la que apunta el "ptr" y la divide
	// y almacena en tres elementos diferentes: un string llamado "cmd",y dos numeros
	// integer llamados "firstPardlneter" y "SecondParameter".
	// De esta forma, podemos introducir información al micro desde el puerto
	sscanf(prtBufferReception, "%s %u %u %s", cmd, &firstParameter, &secondParameter, userMsg);

	// Este primer comando imprime una lista con los otros comandos que tiene el equipo
	if(strcmp(cmd, "help") == 0){

		writeMsg(&handlerUsart2, "Help Menu CMDs:\n");
		writeMsg(&handlerUsart2, "1) help    -- Print this menu\n");
		writeMsg(&handlerUsart2, "2) dummy #A #B -- dummy cmd, #A and #B are uint32_t\n");
		writeMsg(&handlerUsart2, "3) usermsg # # msg -- msg is a string comming from outside\n");
		writeMsg(&handlerUsart2, "4) initLcd -- simple Test for the LCD\n");
		writeMsg(&handlerUsart2, "5) testLcd -- simple Test for the LCD\n");
		writeMsg(&handlerUsart2, "6) setPeriod  -- Change the Led_state period (us)\n");
		writeMsg(&handlerUsart2, "7) autoUpdate # -- Automatic LCD update (# -> 1/0\n)");
	}
	// El comando dummy sirve para entender como funciona la recepción de números enviados
	// desde la consola
	else if (strcmp(cmd,"dummy")== 0) {
		writeMsg (&handlerUsart2,"CMD: dummy\n" ) ;
		// Cambiando el formato para presentar el número por el puerto serial
		sprintf(bufferData,"number A = %u\n",firstParameter);
		writeMsg(&handlerUsart2, bufferData);

		// Cambiando el formato para presentar el número por el puerto serial
		sprintf(bufferData,"number B= %u\n", secondParameter) ;
		writeMsg (&handlerUsart2, bufferData);
	}

	else if (strcmp(cmd,"stateled")== 0) {
		handlerStateTimer.TIMx_Config.TIMx_speed		= BTIMER_SPEED_1ms;
		handlerStateTimer.TIMx_Config.TIMx_period		= 50;
		// Cargamos la configuración del timer
		BasicTimer_Config(&handlerStateTimer);

		// Activamos el TIM2
		starTimer(&handlerStateTimer);
		writeMsg(&handlerUsart2, "Se prueba con el led de estado aumentado la velocidad");


	}


}



/*
 * Funcion encargada de la inicializacion de los elementos del sistema
 */
void InitSystem(void){
//_----------------------------------------ClockPLL----------------------------------------------------------

	//--------------PLL-----------------------------------------------
	// Se configura el pin A8 para que por este salga la frecuencia del reloj principal
	//Esto es opcional
	handlerMCO1Pin.pGPIOx = GPIOA;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinNumber = PIN_8;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEED_FAST;

	// Se carga la configuracion del pin A8
	GPIO_Config(&handlerMCO1Pin);

	// Se configura los parametros para la frecuencia
	handlerPllMCO.CLOCK_Config.frequency = MCU_FREQUENCY_100MHz;
	frequencyClock(&handlerPllMCO);
	configPll(&handlerPllMCO);



//-----------------------------------------StateLed----------------------------------------------------------


	handlerStateTimer.ptrTIMx 						= TIM2;
	handlerStateTimer.TIMx_Config.TIMx_mode			= BTIMER_MODE_UP;
	handlerStateTimer.TIMx_Config.TIMx_speed		= BTIMER_80SPEED_1ms;
	handlerStateTimer.TIMx_Config.TIMx_period		= 250;

	// Cargamos la configuración del timer
	BasicTimer_Config(&handlerStateTimer);

	// Activamos el TIM2
	starTimer(&handlerStateTimer);



//--------------------------------------CMD-Comunication------------------------------------------------------
	// Configurando el pin para el Led_Blinky
	handlerStateLed.pGPIOx 								= GPIOA;
	handlerStateLed.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerStateLed.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerStateLed.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerStateLed.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerStateLed.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	// Cargamos la configuración del Pin del led de estado
	GPIO_Config(&handlerStateLed);

	// Llevamos el Led a un estado de encendido
	GPIO_WritePin(&handlerStateLed, RESET);

	/* Configurando los pines sobre los que funciona el USART2 (TX) */
	handlerPinTx.pGPIOx 							= GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber		= PIN_9;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode	= AF7;
	GPIO_Config(&handlerPinTx);

	/* Configurando los pines sobre los que funciona el USART2 (RX) */
	handlerPinRx.pGPIOx 							= GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber		= PIN_10;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode	= AF7;
	GPIO_Config(&handlerPinRx);

	// Configurando la comunicación serial (Cable verde es TX, Cable Blanco es RX)
	handlerUsart2.ptrUSARTx 					= USART1;
	handlerUsart2.USART_Config.MCU_frecuency 	= USART_MCU_FREQUENCY_100MHz;
	handlerUsart2.USART_Config.USART_baudrate	= USART_BAUDRATE_115200;
	handlerUsart2.USART_Config.USART_datasize	= USART_DATASIZE_8BIT;
	handlerUsart2.USART_Config.USART_parity		= USART_PARITY_NONE;
	handlerUsart2.USART_Config.USART_stopbits	= USART_STOPBIT_1;
	handlerUsart2.USART_Config.USART_mode		= USART_MODE_RXTX;
	handlerUsart2.USART_Config.USART_enableInterrupt = USART_RX_INTERRUP_ENABLE ;

	// Cargamos la configuración del USART
	USART_Config(&handlerUsart2);


}

/* Callback del Timer2 - Hacemos un blinky... */
void BasicTimer2_Callback(void){
	handlerStateLed.pGPIOx -> ODR ^= GPIO_ODR_OD5;		// Encendido y apagado StateLED
}

/* Callback relacionado con la recepción del USART2
 * El puerto es leido en la ISR (para bajar la bandera de la interrupción)
 * El caracter que se lee es devuelto por la función getRxData
 */
void usart1_Callback(void){
	// Leemos el valor del registro DR, donde se almacena el dato que llega.
	// Esto además debe bajar la bandera de la interrupción
	rxData = getRxData();
}

