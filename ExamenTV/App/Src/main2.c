/*
 * main2.c
 *
 *  Created on: 28/05/2023
 *      Author: marianela
 */


/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

// se incluyen archivos de cabecera que necesitamos en el proyecto
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include "stm32f4xx.h"
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "PllDriver.h"
#include "RtcDriver.h"
#include "AdcDriver.h"





// Definicion de los handlers necesarios
GPIO_Handler_t handlerStateLed = {0};
GPIO_Handler_t handlerPinTx		= {0};
GPIO_Handler_t handlerPinRx		= {0};

// Timer encargado del Blinky
BasicTimer_Handler_t handlerStateTimer = {0};

// Utilizar USART 1
USART_Handler_t handlerUsart1 = {0};

// RTC para la fecha y hora
handlerRTC_t handlerFechaActual = {0};





uint8_t rxData = 0;
char bufferData[64];
char cmd[64];
#define BUFFER_SIZE 150
char bufferReception[BUFFER_SIZE];
uint8_t counterReception;
bool stringComplete = false;
char userMsg[64] = "\0";

unsigned int firstParameter;
unsigned int secondParameter;
unsigned int secondParameter;

//Pll

CLOCK_Handler_t handlerFrequency = {0};
CLOCK_Handler_t handlerPllMCO = {0};
CLOCK_Handler_t handlerClockMCO = {0};

GPIO_Handler_t handlerMCO1Pin = {0};

//ADC

ADC_Config_t adcConfigChanels = {0};


/* Definición de prototipos de funciones */
void InitSystem(void);
void parseCommands(char *prtBufferReception);


void prescalerCommands(void);
/**
 * Funcion principal del programa.
 * Esta funcion es el corazón del programa!!
 *
 * */
int main(void) {

	// Inicializamos todos los elementos del sistema en una configuracion prestablecida
	// Como reloj del sistema se establece el PLL por defecto a una frecuencia de 100MHz
	InitSystem();

	/* Loop forever */
	while (1) {



		// Creamos una cadena de caracteres con los datos que llegan por el
		// El caracter '@' nos indica que es el finall de la cadena
		if (rxData !=0){
			bufferReception[counterReception] = rxData;
			counterReception++;
			// si el carácter entrante es una nueva línea, establece una bandera
			// para que el ciclo principal pueda hacer algo al respecto:
			if ( rxData == '@'){
				stringComplete = true;
				// Agrego esta linea para crear el string con el null al fin
				bufferReception[counterReception] = '\0';
				counterReception = 0;
			}
			//Para ue no vuelva a entrar. Solo cambia debido a la interrupción
			rxData = '\0';
		}
		//Hacemos un analisis de la cadena de datos obtenida
		if(stringComplete){
			parseCommands(bufferReception);
			stringComplete = false;
		}


	}

	return 0;
}




void parseCommands(char *prtBufferReception){

	// Esta función de C lee la cadena de caracteres a la que apunta el "ptr" y la divide
	// y almacena en tres elementos diferentes: un string llamado "cmd",y dos numeros
	// integer llamados "firstPardlneter" y "SecondParameter".
	// De esta forma, podemos introducir información al micro desde el puerto
	sscanf(prtBufferReception, "%s %u %u %s", cmd, &firstParameter, &secondParameter, userMsg);

	// Este primer comando imprime una lista con los otros comandos que tiene el equipo
	if(strcmp(cmd, "help") == 0){


		writeMsg(&handlerUsart1, "1) help    -- Menu de Funciones:\n"
									"Para ativar alguna de las funciones escriba la palabra clave,\n seguida del numero de configuracion \n"
									"finalice con el caracter '@' \n");

		writeMsg(&handlerUsart1, "                                                                                                            "
				"                                                                                                                              \n");

		writeMsg(&handlerUsart1, "2) prescaler --- Seleccione el prescaler con el cual quiere obtener su señal en el MCO\n"
									 "Marque 0 para obtener la señal sin prescaler\n"
									 "Marque 2 si desea una division por 2 \n"
									 "Marque 3 si desea una division por 3\n"
									 "Marque 4 si desea una division por 4\n"
									 "Marque 5 si deses una division por 5\n");

		writeMsg(&handlerUsart1, "                                                                                                            "
					"                                                                                                                              \n");


		writeMsg(&handlerUsart1, "3) Clock --- Seleccione el tipo de reloj que desea utilizar en el MCO\n"
									"Marque 1 para seleccionar el reloj HSI a 16MHz\n"
									"Marque 2 para seleccionar el reloj LSE a  32.768 kHz\n"
									"Marque 3 para seleccionar el reloj PLL a 100MHz \n");


		writeMsg(&handlerUsart1, "                                                                                                            "
					"                                                                                                                              \n");



		writeMsg(&handlerUsart1, "3) usermsg # # msg -- msg is a string comming from outside\n");
	}

	//Comando "prescaler" es el encargado de definir la division por la cual desea obtener su señal de reloj en el MCO pin A8

	else if (strcmp(cmd,"prescaler")== 0){
		//Se llama a la funcion de comandos
			prescalerCommands();
	}

	//Comando "clock" es el encargado de definir el tipo de reloj que se desa activar en el MCO pin A8
	else if (strcmp(cmd,"clock")== 0) {

		switch(firstParameter){

		case 1:
			//Se escribe un mensaje
			writeMsg(&handlerUsart1, "     reloj HSI\n");

			//Se establece la configuracuin como reloj HSI
			handlerClockMCO.CLOCK_Config.clock = CLOCK_HSI;
			//prescalerCommands();
			//Se llama a la funcion que configura el reloj HSI
			typeClock(&handlerClockMCO);


			break;

		case 2:
			// Se escrube un Mensaje
			writeMsg(&handlerUsart1, "      reloj LSE\n");
			//Se establece la configuracion como LSE
			handlerClockMCO.CLOCK_Config.clock = CLOCK_LSE;
			//prescalerCommands();
			//Se llama a la funcion que configura el reloj LSE deshabilitando la proteccion en el PWR y activando el LSE
			typeClock(&handlerClockMCO);


			break;

		case 3:

			//Se escribe un mensaje
			writeMsg(&handlerUsart1, "     reloj PLL\n");

			//prescalerCommands();

			//En este caso al ser la configuracion base no se requiere configurar a PLL
			//Solo se llama la funcion
			configPll(&handlerPllMCO);

			break;

	    default:
	        // Valor inválido, no hacer nada o mostrar un mensaje de error
	    	//writeMsg(&handlerUsart1, "Comando Invalido, escriba una valor correcto seguido del caracter '@' \n");
	        return;
		}



	}

	else if(strcmp(cmd,"getDate")== 0){


		getTime(&handlerFechaActual);
		writeMsg(&handlerUsart1, " estoy aqui\n");
		// Convertir los valores obtenidos a una cadena de caracteres
		char buffer[50];
		 snprintf(buffer, sizeof(buffer), "Fecha y hora: %02d/%02d/%02d %02d:%02d:%02d\r\n",
				 handlerFechaActual.day , handlerFechaActual.month, handlerFechaActual.year,
				 handlerFechaActual.hour, handlerFechaActual.minute, handlerFechaActual.seconds);

		    // Enviar la cadena de caracteres a través de USART1
		// writeMsg(&handlerUsart1, " estoy aqui\n");
		 writeMsg(&handlerUsart1, buffer);


	}

	else if(strcmp(cmd,"setDate")== 0){

		unsigned int am_pm;
		unsigned int hour;
		unsigned int minute;
		unsigned int seconds;
		unsigned int format_hour;
		unsigned int day;
		unsigned int month;
		unsigned int year;


		// Leer la configuración ingresada por el usuario
		sscanf(prtBufferReception, "%*s %u %u %u %u %u %u %u %u", &am_pm, &hour, &minute, &seconds, &format_hour, &day, &month, &year);

		// Asignar los valores a los campos correspondientes de la estructura handlerFechaActual
		handlerFechaActual.AM_PM = (uint8_t)am_pm;
		handlerFechaActual.hour = (uint8_t)hour;
		handlerFechaActual.minute = (uint8_t)minute;
		handlerFechaActual.seconds = (uint8_t)seconds;
		handlerFechaActual.format_hour = (uint8_t)format_hour;
		handlerFechaActual.day = (uint8_t)day;
		handlerFechaActual.month = (uint8_t)month;
		handlerFechaActual.year = (uint16_t)year;


		// Verificar si se seleccionó el formato de hora militar
		if (format_hour == 0) {
		    // Formato de 12 horas
		    // Realizar la conversión al formato de 24 horas si es necesario
		    if (handlerFechaActual.AM_PM == 1 && handlerFechaActual.hour < 12) {
		        // Si es PM y la hora es menor a 12, sumar 12 horas
		        handlerFechaActual.hour += 12;
		    } else if (handlerFechaActual.AM_PM == 0 && handlerFechaActual.hour == 12) {
		        // Si es AM y la hora es 12, convertir a 0 (medianoche)
		        handlerFechaActual.hour = 0;
		    }
		}

		// Verificar si el formato de hora es de 12 horas y ajustar la hora si es necesario
		if (format_hour == 1) {
		    if (am_pm == 1 && hour < 12) {
		        // Si es PM y la hora es menor a 12, sumar 12 horas
		        handlerFechaActual.hour += 12;
		    } else if (am_pm == 0 && hour == 12) {
		        // Si es AM y la hora es 12, cambiar a 0 horas
		        handlerFechaActual.hour = 0;
		    }
		}

		// Verificar y ajustar los valores de fecha y hora si se exceden los límites
		// Asumiendo que los meses son del 1 al 12 y los días van del 1 al 31
		if (handlerFechaActual.month > 12) {
		    handlerFechaActual.month = 1;
		    handlerFechaActual.year++;
		}
		if (handlerFechaActual.day > 31) {
		    handlerFechaActual.day = 1;
		    handlerFechaActual.month++;
		    if (handlerFechaActual.month > 12) {
		        handlerFechaActual.month = 1;
		        handlerFechaActual.year++;
		    }
		}

		setTime(&handlerFechaActual);

		// Convertir los valores obtenidos a una cadena de caracteres
		char buffer[150];
		char am_pm_str[3];

		// Determinar si es AM o PM
		if (handlerFechaActual.AM_PM == 0) {
		    strcpy(am_pm_str, "AM");
		} else {
		    strcpy(am_pm_str, "PM");
		}

		snprintf(buffer, sizeof(buffer), "Fecha y hora: %02d/%02d/%02d %02d:%02d:%02d %s\r\n",
		         handlerFechaActual.day, handlerFechaActual.month, handlerFechaActual.year,
		         handlerFechaActual.hour, handlerFechaActual.minute, handlerFechaActual.seconds,
		         am_pm_str);

		    // Enviar la cadena de caracteres a través de USART1
		// writeMsg(&handlerUsart1, " estoy aqui\n");
		 writeMsg(&handlerUsart1, buffer);

	}






}

/*La funcion prescalerCommands llama los diferentes casos en donde se puede configurar el prescaler,
 * /para esto, comfigura el prescaler de la configuracion del reloj y luego llama a la funcion prescalerClock*/
void prescalerCommands(void){

	switch(firstParameter){
	case 0:
		handlerClockMCO.CLOCK_Config.prescaler= NO_DIVISION;
		prescalerClock(&handlerClockMCO);


		break;

	case 2:
		handlerClockMCO.CLOCK_Config.prescaler= DIVISION_BY2;
		prescalerClock(&handlerClockMCO);


		break;

	case 3:

		handlerClockMCO.CLOCK_Config.prescaler= DIVISION_BY3;
		prescalerClock(&handlerClockMCO);


		break;

	case 4:
		handlerClockMCO.CLOCK_Config.prescaler= DIVISION_BY4;
		prescalerClock(&handlerClockMCO);


		break;

	case 5:
		handlerClockMCO.CLOCK_Config.prescaler= DIVISION_BY5;
		prescalerClock(&handlerClockMCO);


		break;

    default:
        // Valor inválido, no hacer nada o mostrar un mensaje de error
        return;
	}

}


/*
 * Funcion encargada de la inicializacion de los elementos del sistema
 */
void InitSystem(void){
//_----------------------------------------ClockPLL----------------------------------------------------------

	//--------------PLL-----------------------------------------------
	// Se configura el pin A8 para que por este salga la frecuencia del reloj principal
	//Esto es opcional
	handlerMCO1Pin.pGPIOx = GPIOA;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinAltFunMode = AF0;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTFN;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinNumber = PIN_8;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	handlerMCO1Pin.GPIO_PinConfig.GPIO_PinSpeed = GPIO_OSPEED_FAST;

	// Se carga la configuracion del pin A8
	GPIO_Config(&handlerMCO1Pin);

	// Se configura los parametros para la frecuencia
	handlerPllMCO.CLOCK_Config.frequency = MCU_FREQUENCY_100MHz;

	frequencyPLLClock(&handlerPllMCO);
	configPll(&handlerPllMCO);



//-----------------------------------------StateLed----------------------------------------------------------


	handlerStateTimer.ptrTIMx 						= TIM2;
	handlerStateTimer.TIMx_Config.TIMx_mode			= BTIMER_MODE_UP;
	handlerStateTimer.TIMx_Config.TIMx_speed		= BTIMER_80SPEED_1ms;
	handlerStateTimer.TIMx_Config.TIMx_period		= 250;

	// Cargamos la configuración del timer
	BasicTimer_Config(&handlerStateTimer);

	// Activamos el TIM2
	starTimer(&handlerStateTimer);



//--------------------------------------CMD-Comunication------------------------------------------------------
	// Configurando el pin para el Led_Blinky
	handlerStateLed.pGPIOx 								= GPIOA;
	handlerStateLed.GPIO_PinConfig.GPIO_PinNumber		= PIN_5;
	handlerStateLed.GPIO_PinConfig.GPIO_PinMode			= GPIO_MODE_OUT;
	handlerStateLed.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerStateLed.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerStateLed.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;

	// Cargamos la configuración del Pin del led de estado
	GPIO_Config(&handlerStateLed);

	// Llevamos el Led a un estado de encendido
	GPIO_WritePin(&handlerStateLed, RESET);

	/* Configurando los pines sobre los que funciona el USART2 (TX) */
	handlerPinTx.pGPIOx 							= GPIOA;
	handlerPinTx.GPIO_PinConfig.GPIO_PinNumber		= PIN_9;
	handlerPinTx.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinTx.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinTx.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinTx.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinTx.GPIO_PinConfig.GPIO_PinAltFunMode	= AF7;
	GPIO_Config(&handlerPinTx);

	/* Configurando los pines sobre los que funciona el USART2 (RX) */
	handlerPinRx.pGPIOx 							= GPIOA;
	handlerPinRx.GPIO_PinConfig.GPIO_PinNumber		= PIN_10;
	handlerPinRx.GPIO_PinConfig.GPIO_PinMode		= GPIO_MODE_ALTFN;
	handlerPinRx.GPIO_PinConfig.GPIO_PinOPType		= GPIO_OTYPE_PUSHPULL;
	handlerPinRx.GPIO_PinConfig.GPIO_PinPuPdControl	= GPIO_PUPDR_NOTHING;
	handlerPinRx.GPIO_PinConfig.GPIO_PinSpeed		= GPIO_OSPEED_FAST;
	handlerPinRx.GPIO_PinConfig.GPIO_PinAltFunMode	= AF7;
	GPIO_Config(&handlerPinRx);

	// Configurando la comunicación serial (Cable verde es TX, Cable Blanco es RX)
	handlerUsart1.ptrUSARTx 					= USART1;
	handlerUsart1.USART_Config.MCU_frecuency 	= USART_MCU_FREQUENCY_100MHz;
	handlerUsart1.USART_Config.USART_baudrate	= USART_BAUDRATE_115200;
	handlerUsart1.USART_Config.USART_datasize	= USART_DATASIZE_8BIT;
	handlerUsart1.USART_Config.USART_parity		= USART_PARITY_NONE;
	handlerUsart1.USART_Config.USART_stopbits	= USART_STOPBIT_1;
	handlerUsart1.USART_Config.USART_mode		= USART_MODE_RXTX;
	handlerUsart1.USART_Config.USART_enableInterrupt = USART_RX_INTERRUP_ENABLE ;

	// Cargamos la configuración del USART
	USART_Config(&handlerUsart1);

//------------------------------------------ADC------------------------------------------------


	//Se coofigura en CHANNEL0 para la ADC
	adcConfigChanels.resolution = ADC_RESOLUTION_12_BIT;
	adcConfigChanels.dataAlignment = ADC_ALIGNMENT_RIGHT;


	adcConfigChanels.channels[1] = ADC_CHANNEL_1;
	adcConfigChanels.channels[2] = ADC_CHANNEL_2;

	multiChannelConfig(&adcConfigChanels, 2);






}
/* Callback del Timer2 - Hacemos un blinky... */
void BasicTimer2_Callback(void){
	handlerStateLed.pGPIOx -> ODR ^= GPIO_ODR_OD5;		// Encendido y apagado StateLED
}

/* Callback relacionado con la recepción del USART2
 * El puerto es leido en la ISR (para bajar la bandera de la interrupción)
 * El caracter que se lee es devuelto por la función getRxData
 */
void usart1_Callback(void){
	// Leemos el valor del registro DR, donde se almacena el dato que llega.
	// Esto además debe bajar la bandera de la interrupción
	rxData = getRxData();
}

